import React, { createContext, useContext, useState, useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';

interface Action {
  id: string;
  title: string;
  description: string;
  impact: number;
  status: 'todo' | 'in-progress' | 'completed' | 'delayed';
  progress: number;
  deadline: string;
  scope: string;
  cost: number;
  estimatedReduction: number;
  calculationId?: string;
  priority: 'low' | 'medium' | 'high';
  implementationTime: string;
  category: string;
  responsible?: string;
  isAutoGenerated?: boolean;
}

interface ActionsContextType {
  actions: Action[];
  addAction: (action: Omit<Action, 'id'>) => Promise<void>;
  updateAction: (id: string, updates: Partial<Action>) => Promise<void>;
  deleteAction: (id: string) => Promise<void>;
  clearAllActions: () => Promise<void>;
  getTotalImpact: () => number;
  getCompletedImpact: () => number;
  getTotalCost: () => number;
  getActionsProgress: () => number;
  getActionsByScope: (scope: string) => Action[];
  saveToSupabase: () => Promise<void>;
  loadFromSupabase: () => Promise<void>;
  generateSuggestedActions: (emissionsData: any) => Action[];
  filteredActions: Action[];
  setFilters: (filters: ActionFilters) => void;
  sortActions: (field: string, direction: 'asc' | 'desc') => void;
  exportToPDF: () => Promise<void>;
  exportToExcel: () => Promise<void>;
}

interface ActionFilters {
  status?: string[];
  scope?: string[];
  priority?: string[];
  search?: string;
}

const ActionsContext = createContext<ActionsContextType | undefined>(undefined);

export const ActionsProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [actions, setActions] = useState<Action[]>([]);
  const [filters, setFiltersState] = useState<ActionFilters>({});
  const [sortField, setSortField] = useState<string>('deadline');
  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('asc');

  // Local persistence fallback when user is not authenticated
  const STORAGE_KEY = 'carbon_actions_local';
  const saveLocal = (list: Action[]) => {
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(list)); } catch (e) { console.error('Erreur lors de la sauvegarde locale:', e); }
  };
  const loadFromLocalStorage = () => {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw) {
        const parsed: Action[] = JSON.parse(raw);
        setActions(parsed);
      }
    } catch (e) { console.error('Erreur lors du chargement local:', e); }
  };
  const isUUID = (id: string) => /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/.test(id);
  const migrateLocalToSupabase = async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      const local: Action[] = JSON.parse(raw);
      const toInsert = local.filter(a => !isUUID(a.id));
      if (toInsert.length === 0) return;
      const payload = toInsert.map(a => ({
        user_id: user.id,
        title: a.title,
        description: a.description,
        estimated_reduction_kg: a.impact * 1000,
        estimated_cost: a.cost,
        target_date: a.deadline,
        scope_type: a.scope,
        status: a.status,
        priority: a.priority,
        implementation_time: a.implementationTime,
        category: a.category,
        estimated_reduction_percent: a.estimatedReduction,
        progress: a.progress || 0,
        calculation_id: a.calculationId
      }));
      await supabase.from('carbon_actions').insert(payload);
      localStorage.removeItem(STORAGE_KEY);
    } catch (e) { console.error('Erreur migration locale -> Supabase:', e); }
  };

  const filteredActions = React.useMemo(() => {
    let result = [...actions];

    // Apply filters
    if (filters.status && filters.status.length > 0) {
      result = result.filter(action => filters.status!.includes(action.status));
    }

    if (filters.scope && filters.scope.length > 0) {
      result = result.filter(action => filters.scope!.includes(action.scope));
    }

    if (filters.priority && filters.priority.length > 0) {
      result = result.filter(action => filters.priority!.includes(action.priority));
    }

    if (filters.search && filters.search.length > 0) {
      const search = filters.search.toLowerCase();
      result = result.filter(action => 
        action.title.toLowerCase().includes(search) ||
        action.description.toLowerCase().includes(search) ||
        action.category.toLowerCase().includes(search) ||
        action.responsible?.toLowerCase().includes(search)
      );
    }

    // Apply sorting
    result.sort((a, b) => {
      let aValue: any = a[sortField as keyof Action];
      let bValue: any = b[sortField as keyof Action];

      if (sortField === 'deadline') {
        aValue = new Date(aValue).getTime();
        bValue = new Date(bValue).getTime();
      }

      if (typeof aValue === 'string') {
        aValue = aValue.toLowerCase();
        bValue = bValue.toLowerCase();
      }

      if (aValue < bValue) return sortDirection === 'asc' ? -1 : 1;
      if (aValue > bValue) return sortDirection === 'asc' ? 1 : -1;
      return 0;
    });

    return result;
  }, [actions, filters, sortField, sortDirection]);

  const setFilters = (newFilters: ActionFilters) => {
    setFiltersState(prev => ({ ...prev, ...newFilters }));
  };

  const sortActions = (field: string, direction: 'asc' | 'desc') => {
    setSortField(field);
    setSortDirection(direction);
  };

  const generateSuggestedActions = (emissionsData: any): Action[] => {
    if (!emissionsData) return [];
    
    // This would call the utility function and format results
    const suggestions = [];
    // Implementation would be similar to the utility but return Action[] format
    return suggestions;
  };

  const exportToPDF = async () => {
    const { exportActionsToPDF } = await import('@/utils/exportUtils');
    exportActionsToPDF(filteredActions);
  };

  const exportToExcel = async () => {
    const { exportActionsToExcel } = await import('@/utils/exportUtils');
    exportActionsToExcel(filteredActions);
  };

  useEffect(() => {
    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
      setTimeout(() => {
        if (session?.user) {
          migrateLocalToSupabase().then(() => {
            loadFromSupabase();
          });
        } else {
          loadFromLocalStorage();
        }
      }, 0);
    });

    supabase.auth.getSession().then(({ data: { session } }) => {
      if (session?.user) {
        loadFromSupabase();
      } else {
        loadFromLocalStorage();
      }
    });

    return () => subscription.unsubscribe();
  }, []);

  const loadFromSupabase = async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      const { data: carbonActions, error } = await supabase
        .from('carbon_actions')
        .select('*')
        .eq('user_id', user.id)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Erreur lors du chargement des actions:', error);
        return;
      }

      if (carbonActions) {
        const formattedActions: Action[] = carbonActions.map(action => ({
          id: action.id,
          title: action.title,
          description: action.description,
          impact: Number(action.estimated_reduction_kg || 0) / 1000, // Conversion kg -> tonnes
          status: ((action.status === 'planned' || action.status === 'proposed') ? 'todo' : action.status) as Action['status'],
          progress: Number(action.progress || 0),
          deadline: action.target_date || '',
          scope: action.scope_type,
          cost: Number(action.estimated_cost || 0),
          estimatedReduction: Number(action.estimated_reduction_percent || 0),
          calculationId: action.calculation_id || '',
          priority: action.priority as Action['priority'],
          implementationTime: action.implementation_time || '',
          category: action.category
        }));

        setActions(formattedActions);
        saveLocal(formattedActions);
      }
    } catch (error) {
      console.error('Erreur lors du chargement des actions:', error);
    }
  };

  const saveToSupabase = async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      // Sauvegarder chaque action
      for (const action of actions) {
        const actionData = {
          user_id: user.id,
          title: action.title,
          description: action.description,
          estimated_reduction_kg: action.impact * 1000, // Conversion tonnes -> kg
          estimated_cost: action.cost,
          target_date: action.deadline,
          scope_type: action.scope,
          status: action.status,
          priority: action.priority,
          implementation_time: action.implementationTime,
          category: action.category,
          estimated_reduction_percent: action.estimatedReduction,
          calculation_id: action.calculationId
        };

        if (action.id && action.id.length > 10) {
          // Mise à jour d'une action existante
          await supabase
            .from('carbon_actions')
            .update(actionData)
            .eq('id', action.id)
            .eq('user_id', user.id);
        } else {
          // Création d'une nouvelle action
          await supabase
            .from('carbon_actions')
            .insert(actionData);
        }
      }
    } catch (error) {
      console.error('Erreur lors de la sauvegarde des actions:', error);
    }
  };

  const addAction = async (actionData: Omit<Action, 'id'>) => {
    const newAction: Action = {
      ...actionData,
      id: `temp_${Date.now()}`, // ID temporaire
    };

    setActions(prev => { const updated = [...prev, newAction]; saveLocal(updated); return updated; });

    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      const { data, error } = await supabase
        .from('carbon_actions')
        .insert({
          user_id: user.id,
          title: actionData.title,
          description: actionData.description,
          estimated_reduction_kg: actionData.impact * 1000,
          estimated_cost: actionData.cost,
          target_date: actionData.deadline,
          scope_type: actionData.scope,
          status: actionData.status,
          priority: actionData.priority,
          implementation_time: actionData.implementationTime,
          category: actionData.category,
          estimated_reduction_percent: actionData.estimatedReduction,
          progress: actionData.progress || 0,
          calculation_id: actionData.calculationId
        })
        .select()
        .single();

      if (error) {
        console.error('Erreur lors de l\'ajout:', error);
        return;
      }

      // Mettre à jour avec l'ID réel
      setActions(prev => {
        const updated = prev.map(action => 
          action.id === newAction.id ? { ...action, id: data.id } : action
        );
        saveLocal(updated);
        return updated;
      });
    } catch (error) {
      console.error('Erreur lors de l\'ajout:', error);
    }
  };

  const updateAction = async (id: string, updates: Partial<Action>) => {
    setActions(prev => { const updated = prev.map(action => 
      action.id === id ? { ...action, ...updates } : action
    ); saveLocal(updated); return updated; });

    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      const updateData: any = {};
      if (updates.title) updateData.title = updates.title;
      if (updates.description) updateData.description = updates.description;
      if (updates.impact !== undefined) updateData.estimated_reduction_kg = updates.impact * 1000;
      if (updates.cost !== undefined) updateData.estimated_cost = updates.cost;
      if (updates.deadline) updateData.target_date = updates.deadline;
      if (updates.scope) updateData.scope_type = updates.scope;
      if (updates.status) updateData.status = updates.status;
      if (updates.priority) updateData.priority = updates.priority;
      if (updates.implementationTime) updateData.implementation_time = updates.implementationTime;
      if (updates.category) updateData.category = updates.category;
      if (updates.estimatedReduction !== undefined) updateData.estimated_reduction_percent = updates.estimatedReduction;
      if (updates.progress !== undefined) updateData.progress = updates.progress;

      await supabase
        .from('carbon_actions')
        .update(updateData)
        .eq('id', id)
        .eq('user_id', user.id);
    } catch (error) {
      console.error('Erreur lors de la mise à jour:', error);
    }
  };

  const deleteAction = async (id: string) => {
    setActions(prev => { const updated = prev.filter(action => action.id !== id); saveLocal(updated); return updated; });

    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      await supabase
        .from('carbon_actions')
        .delete()
        .eq('id', id)
        .eq('user_id', user.id);
    } catch (error) {
      console.error('Erreur lors de la suppression:', error);
    }
  };

  const clearAllActions = async () => {
    setActions([]);
    try { localStorage.removeItem(STORAGE_KEY); } catch (_) {}

    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      await supabase
        .from('carbon_actions')
        .delete()
        .eq('user_id', user.id);
    } catch (error) {
      console.error('Erreur lors de la suppression de toutes les actions:', error);
    }
  };

  const getTotalImpact = () => {
    return actions.reduce((sum, action) => sum + action.impact, 0);
  };

  const getCompletedImpact = () => {
    return actions
      .filter(action => action.status === 'completed')
      .reduce((sum, action) => sum + action.impact, 0);
  };

  const getTotalCost = () => {
    return actions.reduce((sum, action) => sum + action.cost, 0);
  };

  const getActionsProgress = () => {
    if (actions.length === 0) return 0;
    const completedActions = actions.filter(action => action.status === 'completed').length;
    return (completedActions / actions.length) * 100;
  };

  const getActionsByScope = (scope: string) => {
    return actions.filter(action => action.scope === scope);
  };

  return (
    <ActionsContext.Provider value={{
      actions,
      addAction,
      updateAction,
      deleteAction,
      clearAllActions,
      getTotalImpact,
      getCompletedImpact,
      getTotalCost,
      getActionsProgress,
      getActionsByScope,
      saveToSupabase,
      loadFromSupabase,
      generateSuggestedActions,
      filteredActions,
      setFilters,
      sortActions,
      exportToPDF,
      exportToExcel
    }}>
      {children}
    </ActionsContext.Provider>
  );
};

export const useActions = () => {
  const context = useContext(ActionsContext);
  if (context === undefined) {
    throw new Error('useActions doit être utilisé dans un ActionsProvider');
  }
  return context;
};