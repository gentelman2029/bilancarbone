import { useState, useMemo } from 'react';

export interface ActionFilters {
  status?: string[];
  scope?: string[];
  priority?: string[];
  search?: string;
}

interface Action {
  id: string;
  title: string;
  description: string;
  impact: number;
  status: 'todo' | 'in-progress' | 'completed' | 'delayed';
  progress: number;
  deadline: string;
  scope: string;
  cost: number;
  estimatedReduction: number;
  calculationId?: string;
  priority: 'low' | 'medium' | 'high';
  implementationTime: string;
  category: string;
  responsible?: string;
  isAutoGenerated?: boolean;
}

export const useActionFilters = (actions: Action[]) => {
  const [filters, setFilters] = useState<ActionFilters>({});
  const [sortField, setSortField] = useState<string>('deadline');
  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('asc');

  const filteredAndSortedActions = useMemo(() => {
    let result = [...actions];

    // Apply filters
    if (filters.status && filters.status.length > 0) {
      result = result.filter(action => filters.status!.includes(action.status));
    }

    if (filters.scope && filters.scope.length > 0) {
      result = result.filter(action => filters.scope!.includes(action.scope));
    }

    if (filters.priority && filters.priority.length > 0) {
      result = result.filter(action => filters.priority!.includes(action.priority));
    }

    if (filters.search && filters.search.length > 0) {
      const search = filters.search.toLowerCase();
      result = result.filter(action => 
        action.title.toLowerCase().includes(search) ||
        action.description.toLowerCase().includes(search) ||
        action.category.toLowerCase().includes(search) ||
        action.responsible?.toLowerCase().includes(search)
      );
    }

    // Apply sorting
    result.sort((a, b) => {
      let aValue: any = a[sortField as keyof Action];
      let bValue: any = b[sortField as keyof Action];

      if (sortField === 'deadline') {
        aValue = new Date(aValue).getTime();
        bValue = new Date(bValue).getTime();
      }

      if (typeof aValue === 'string') {
        aValue = aValue.toLowerCase();
        bValue = bValue.toLowerCase();
      }

      if (aValue < bValue) return sortDirection === 'asc' ? -1 : 1;
      if (aValue > bValue) return sortDirection === 'asc' ? 1 : -1;
      return 0;
    });

    return result;
  }, [actions, filters, sortField, sortDirection]);

  const updateFilters = (newFilters: Partial<ActionFilters>) => {
    setFilters(prev => ({ ...prev, ...newFilters }));
  };

  const updateSort = (field: string, direction: 'asc' | 'desc') => {
    setSortField(field);
    setSortDirection(direction);
  };

  return {
    filteredActions: filteredAndSortedActions,
    filters,
    setFilters: updateFilters,
    sortField,
    sortDirection,
    updateSort
  };
};